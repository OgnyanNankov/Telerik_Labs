// Sum

let number = 10;
let sum = 0;
let i = 1;

while (i <= number) {
    sum = sum + i;
    i++;
}

console.log(`Sum of all numbers from 1 to ${number} = ${sum}`);     // Expected output: Sum of all numbers from 1 to 10 = 55

// Какво прави кодът: Този код изчислява сумата на всички цели числа от 1 до 10 включително.
// Променливи:
// number = 10 – това е горната граница.
// sum = 0 – тук ще се натрупва резултатът.
// i = 1 – брояч, който започва от 1 и се увеличава с 1 при всяка стъпка.
// Условието i <= number означава, че цикълът ще се изпълнява, докато i е по-малко или равно на 10.
// Итерации на цикъла:
// Стъпка	i	sum = sum + i	Ново sum
// 1	    1	  0 + 1	        1
// 2	    2	  1 + 2	        3
// 3	    3	  3 + 3	        6
// 4	    4	  6 + 4	        10
// 5	    5	  10 + 5	    15
// 6	    6	  15 + 6	    21
// 7	    7	  21 + 7	    28
// 8	    8	  28 + 8	    36
// 9	    9	  36 + 9	    45
// 10	   10	  45 + 10	    55
// След последната итерация, i става 11 и вече не отговаря на условието i <= number, така че цикълът приключва.

// Is Prime

let number2 = 37;
let divisor = 2;
let maxDivisor = Math.round(Math.sqrt(number2));                    // корен квадратен от 37 е 6.08, закръглено до 6 с math.round
let isPrime = true;

while (isPrime && (divisor < maxDivisor)) {
    if (number2 % divisor === 0) {
        isPrime = false;
    }
    divisor++;
}

console.log(`${number} is prime = ${isPrime}`);    // Expected output: 37 is prime = true

// Какво прави кодът: Този код проверява дали числото 37 е просто число (т.е. дали се дели само на 1 и на себе си).
// Какво означават променливите?
// let number = 37;                                       - Числото, което проверяваме
// let divisor = 2;                                       - Започваме да проверяваме делимост от 2 нататък
// let maxDivisor = Math.round(Math.sqrt(number));        - Оптимизация: няма смисъл да проверяваме над корен от числото
// let isPrime = true;                                    - Приемаме, че е просто, докато не докажем обратното
//Защо само до √числото?                                  - Ако едно число има делител по-голям от √n, то трябва да има и по-малък – така че проверката до √n е достатъчна.
// Math.sqrt(37) ≈ 6.08 → Math.round(6.08) = 6            - Значи ще проверим само делители от 2 до < 6 (до 5 включително). Защото корен квадратен от 39 е 6.08 или закръглено 6
// Итерации на цикъла:
// Стъпка	divisor	  number % divisor	Делител ли е?	isPrime
// 1	    2	      37 % 2 = 1	    не	           true
// 2	    3	      37 % 3 = 1	    не	           true
// 3	    4	      37 % 4 = 1	    не	           true
// 4	    5	      37 % 5 = 2	    не	           true
// След това divisor става 6, което не е по-малко от maxDivisor, и цикълът спира.
// Обобщение:
// Числото 37 не се дели на нито едно число от 2 до 5, затова е просто (prime).
// Кодът го открива ефективно, като проверява делимост само до √числото.

// Factorial Break

// What is Factorial 
// https://www.youtube.com/watch?v=-FquswEIswk

let n = 6;
let factorial = 1;

while (true) {
    if (n === 1) {
        break;
    }

    factorial = factorial * n;
    n--;
}

console.log(`factorial: ${factorial}`);

// Сега да разгледаме и този код, който изчислява факториел на число, и да обясним всяка стъпка.

// Какво е факториел?
// Факториел от число n (обозначава се n!) е произведението на всички цели числа от n до 1.

// Пример: 6! = 6 × 5 × 4 × 3 × 2 × 1 = 720
// Променливи:
// let n = 6;              // Числото, за което искаме факториел
// let factorial = 1;      // Начална стойност – 1 (не 0, защото 0 щеше да занули всичко)
// Цикълът:
// while (true) {
//   if (n === 1) {
//     break;
//   }

//   factorial = factorial * n;
//   n--;
// }
// while (true) създава безкраен цикъл, който се прекъсва с break, когато n === 1.
// Итерации:
// Стъпка	n	factorial = factorial * n	Ново factorial
// 1	    6	1 × 6	                    6
// 2	    5	6 × 5	                    30
// 3	    4	30 × 4	                    120
// 4	    3	120 × 3	                    360
// 5	    2	360 × 2	                    720
// 6	    1	n === 1,                    прекъсваме	-
// Резултат: factorial: 720
// Точно както очакваме: 6! = 720

// ***************

// Factorial While

let n2 = 6;                                          // Задаваме начална стойност 6
let factorial2 = 1;                                  // Начална стойност на факториела (неутрален елемент при умножение)

while (n2 > 1) {
  factorial2 = factorial2 * n2;
  n2--;
}

console.log(`factorial: ${factorial}`);

// Разглеждане на всяка итерация:
// Стъпка	Стойност на n	Стойност на factorial	       Действие
// 0	    6	            1	                           Старт
// 1	    6	            1 × 6 = 6	                   n-- → 5
// 2	    5	            6 × 5 = 30	                   n-- → 4
// 3	    4	            30 × 4 = 120	               n-- → 3
// 4	    3	            120 × 3 = 360	               n-- → 2
// 5	    2	            360 × 2 = 720	               n-- → 1
// 6	    1	            Цикълът спира (n > 1 е false)  -

// Резултат: factorial: 720  - Тоест, 6! = 720.
